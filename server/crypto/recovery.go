package crypto

import (
	"fmt"
	"time"
)

// ================================================================================
// RECOVERY SYSTEM
// ================================================================================
// Two recovery methods:
// 1. Admin Re-grant: Any admin can wrap DEK for user's new key
// 2. Paper Recovery: 24-word mnemonic stored offline (for disaster recovery)
// ================================================================================

// ================================================================================
// ADMIN RE-GRANT RECOVERY (normal case)
// ================================================================================
// When a user loses their keyfile, an admin can grant them access again.
// The admin wraps the company DEK for the user's NEW public key.
// Server never sees the DEK - zero-knowledge preserved.

// RecoveryRequest is sent by a user who lost their keyfile
type RecoveryRequest struct {
	CompanyID string `json:"company_id"` // Which company to recover access to
	UserLabel string `json:"user_label"` // Who is requesting (for identification)

	// New keys generated by the user
	NewKeyID            string `json:"new_key_id"`
	NewSigningPublicKey []byte `json:"new_signing_public_key"`
	NewKEXPublicKey     []byte `json:"new_kex_public_key"` // [32]byte

	// Proof of identity (out-of-band verification)
	// Admin verifies this via video call, in-person, etc.
	RequestedAt time.Time `json:"requested_at"`
}

// RecoveryGrant is created by an admin to restore access
type RecoveryGrant struct {
	KeyID      string `json:"key_id"`      // New key ID for the recovered user
	CompanyID  string `json:"company_id"`  // Company being granted
	WrappedDEK []byte `json:"wrapped_dek"` // DEK wrapped for user's new KEX public key

	// Admin info (for audit)
	GrantedBy   string    `json:"granted_by"`   // Admin's key ID
	GrantedAt   time.Time `json:"granted_at"`   // When granted
	UserLabel   string    `json:"user_label"`   // Label for the new key
	Role        string    `json:"role"`         // Role to assign
}

// PrepareRecoveryRequest creates a recovery request for a user who lost access
func PrepareRecoveryRequest(companyID, userLabel string) (*RecoveryRequest, *PartialKeyfile, error) {
	// Generate new key pair for signing
	signingKP, err := GenerateSigningKeyPair()
	if err != nil {
		return nil, nil, err
	}

	// Generate new KEX key pair
	kexKP, err := GenerateX25519KeyPair()
	if err != nil {
		return nil, nil, err
	}

	// Generate key ID
	keyID, err := GenerateKeyID()
	if err != nil {
		return nil, nil, err
	}

	request := &RecoveryRequest{
		CompanyID:           companyID,
		UserLabel:           userLabel,
		NewKeyID:            keyID,
		NewSigningPublicKey: signingKP.PublicKey,
		NewKEXPublicKey:     kexKP.PublicKey[:],
		RequestedAt:         time.Now().UTC(),
	}

	// Partial keyfile (missing DEK, will be filled after grant)
	partial := &PartialKeyfile{
		KeyID:             keyID,
		CompanyID:         companyID,
		UserLabel:         userLabel,
		SigningPrivateKey: signingKP.PrivateKey,
		SigningPublicKey:  signingKP.PublicKey,
		KEXPrivateKey:     kexKP.PrivateKey,
		KEXPublicKey:      kexKP.PublicKey,
	}

	return request, partial, nil
}

// PartialKeyfile is a keyfile missing the DEK (waiting for admin grant)
type PartialKeyfile struct {
	KeyID             string
	CompanyID         string
	UserLabel         string
	SigningPrivateKey []byte
	SigningPublicKey  []byte
	KEXPrivateKey     [32]byte
	KEXPublicKey      [32]byte
}

// CompleteWithGrant completes the partial keyfile with an admin's grant
func (p *PartialKeyfile) CompleteWithGrant(grant *RecoveryGrant) (*Keyfile, error) {
	// Unwrap DEK using our KEX private key
	dek, err := UnwrapDEK(grant.WrappedDEK, p.KEXPrivateKey)
	if err != nil {
		return nil, fmt.Errorf("failed to unwrap DEK: %w", err)
	}

	return &Keyfile{
		KeyID:             p.KeyID,
		CompanyID:         p.CompanyID,
		UserLabel:         p.UserLabel,
		Role:              grant.Role,
		SigningPrivateKey: p.SigningPrivateKey,
		SigningPublicKey:  p.SigningPublicKey,
		KEXPrivateKey:     p.KEXPrivateKey,
		KEXPublicKey:      p.KEXPublicKey,
		CompanyDEK:        dek,
		BlindIndexKey:     DeriveBlindIndexKey(dek),
		IssuedAt:          time.Now().UTC(),
	}, nil
}

// GrantAccessToUser creates a recovery grant (called by admin)
func (kf *Keyfile) GrantAccessToUser(request *RecoveryRequest, role string) (*RecoveryGrant, error) {
	if !kf.CanGrantAccess() {
		return nil, fmt.Errorf("keyfile with role '%s' cannot grant access", kf.Role)
	}

	if kf.CompanyID != request.CompanyID {
		return nil, fmt.Errorf("keyfile company mismatch")
	}

	// Convert KEX public key
	var recipientKEX [32]byte
	copy(recipientKEX[:], request.NewKEXPublicKey)

	// Wrap DEK for recipient
	wrappedDEK, err := kf.WrapDEKForUser(recipientKEX)
	if err != nil {
		return nil, fmt.Errorf("failed to wrap DEK: %w", err)
	}

	return &RecoveryGrant{
		KeyID:      request.NewKeyID,
		CompanyID:  kf.CompanyID,
		WrappedDEK: wrappedDEK,
		GrantedBy:  kf.KeyID,
		GrantedAt:  time.Now().UTC(),
		UserLabel:  request.UserLabel,
		Role:       role,
	}, nil
}

// ================================================================================
// PAPER RECOVERY (disaster recovery)
// ================================================================================
// For when ALL admins lose access simultaneously (rare but possible).
// A 24-word mnemonic is generated at company creation and stored offline.
// This mnemonic can decrypt a backup of the DEK stored on server.

// PaperRecovery holds the data needed for paper-based disaster recovery
type PaperRecovery struct {
	Mnemonic     string `json:"-"`              // 24 words - NEVER stored on server
	RecoveryBlob []byte `json:"recovery_blob"`  // DEK encrypted with key derived from mnemonic
	CompanyID    string `json:"company_id"`
	CreatedAt    time.Time `json:"created_at"`
}

// GeneratePaperRecovery creates a paper recovery backup
// The mnemonic should be written down and stored in a safe
func GeneratePaperRecovery(companyID string, companyDEK []byte) (*PaperRecovery, error) {
	// Generate 24-word mnemonic
	mnemonic, _, err := GenerateMnemonic()
	if err != nil {
		return nil, err
	}

	// Derive encryption key from mnemonic
	recoveryKey := MnemonicToKey(mnemonic)

	// Encrypt DEK with recovery key
	recoveryBlob, err := EncryptAESGCM(recoveryKey, companyDEK)
	if err != nil {
		return nil, err
	}

	return &PaperRecovery{
		Mnemonic:     mnemonic, // User must write this down
		RecoveryBlob: recoveryBlob,
		CompanyID:    companyID,
		CreatedAt:    time.Now().UTC(),
	}, nil
}

// RecoverFromMnemonic recovers access using the paper recovery key
func RecoverFromMnemonic(mnemonic string, recoveryBlob []byte, userLabel string) (*Keyfile, error) {
	// Derive recovery key from mnemonic
	recoveryKey := MnemonicToKey(mnemonic)

	// Decrypt DEK
	dek, err := DecryptAESGCM(recoveryKey, recoveryBlob)
	if err != nil {
		return nil, fmt.Errorf("invalid recovery key or corrupted backup")
	}

	// Generate company ID (we don't have it, but server does)
	companyID, err := GenerateCompanyID()
	if err != nil {
		return nil, err
	}

	// Create new keyfile with recovered DEK
	return NewKeyfile(companyID, userLabel, "owner", dek)
}

// RecoverFromMnemonicWithCompanyID recovers with known company ID
func RecoverFromMnemonicWithCompanyID(mnemonic string, recoveryBlob []byte, companyID, userLabel string) (*Keyfile, error) {
	// Derive recovery key from mnemonic
	recoveryKey := MnemonicToKey(mnemonic)

	// Decrypt DEK
	dek, err := DecryptAESGCM(recoveryKey, recoveryBlob)
	if err != nil {
		return nil, fmt.Errorf("invalid recovery key or corrupted backup")
	}

	// Create new keyfile with recovered DEK
	return NewKeyfile(companyID, userLabel, "owner", dek)
}

// ================================================================================
// RECOVERY FLOW SUMMARY
// ================================================================================
//
// NORMAL RECOVERY (user loses keyfile, admins still have access):
// 1. User: PrepareRecoveryRequest() → sends public keys to admin
// 2. Admin: Verifies user identity (video call, in-person, etc.)
// 3. Admin: GrantAccessToUser() → creates RecoveryGrant with wrapped DEK
// 4. User: CompleteWithGrant() → creates new keyfile with DEK
// 5. User: Saves new keyfile with password
//
// DISASTER RECOVERY (all admins lost access):
// 1. User: Retrieves 24-word mnemonic from safe deposit box
// 2. User: Retrieves recovery_blob from server
// 3. User: RecoverFromMnemonic() → creates new owner keyfile
// 4. User: Re-grants access to other users
//
// ================================================================================
